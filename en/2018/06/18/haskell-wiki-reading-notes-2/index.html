<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Mondo Gao"><title>Haskell Wiki Reading Notes 2 - Elementary · 麦冬</title><meta name="description" content="RecursionNumeric recursion12345factorial 0 = 1factorial n = n * factorial (n - 1)-- declared in one line, use ; to seperatelet factorial 0 = 1; factor"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><h3 title=""><a href="/">麦冬</a></h3><div class="description"><p>前端、杂谈、设计、艺术。</p></div></div></div><ul class="social-links"><li><a href="mailto:mondogao@gmail.com?Subject=Let's be friends!"><i class="fa fa-envelope"></i></a></li><li><a href="http://weibo.com/MondoGao"><i class="fa fa-weibo"></i></a></li><li><a href="https://twitter.com/mondo_gao"><i class="fa fa-twitter"></i></a></li><li><a href="http://facebook.com/MondoGao"><i class="fa fa-facebook"></i></a></li><li><a href="http://instagram.com/mondogao"><i class="fa fa-instagram"></i></a></li><li><a href="http://github.com/mondogao"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><div class="by_farbox"><a href="https://hexo.io/" target="_blank">Powered by Hexo</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">About</a></li><li><a href="/archives">Archive</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="https://www.gravatar.com/avatar/ef6553e3101c4dd8130672b2332a7472"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Haskell Wiki Reading Notes 2 - Elementary</a></h3></div><div class="post-content"><h1 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h1><h2 id="Numeric-recursion"><a href="#Numeric-recursion" class="headerlink" title="Numeric recursion"></a>Numeric recursion</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">factorial</span> <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">factorial</span> n = n * factorial (n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- declared in one line, use ; to seperate</span></span><br><span class="line"><span class="title">let</span> factorial <span class="number">0</span> = <span class="number">1</span>; factorial n = n \* factorial (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">factorial</span> n = product [<span class="number">1.</span>.n]</span><br></pre></td></tr></table></figure>
<p>Haskell decides which function definition to use by starting at the top. So, <strong>always list multiple function definitions starting with the most specific</strong>.</p>
<h2 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h2><p>Translate a loop into recursive form by making loop variables into an argument.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">factorial</span> n = go n <span class="number">1</span></span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">  go n res</span><br><span class="line">    | n &gt; <span class="number">1</span> = go (n - <span class="number">1</span>) (res * n)</span><br><span class="line">    | otherwise = res</span><br></pre></td></tr></table></figure>
<h2 id="List-based-recursion"><a href="#List-based-recursion" class="headerlink" title="List based recursion"></a>List based recursion</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">length</span> :: [a] -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">length</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">length</span> (x:xs) = <span class="number">1</span> + length xs</span><br><span class="line"></span><br><span class="line">(++) :: [a] -&gt; [a] -&gt; [a]</span><br><span class="line">[] ++ ys     = ys</span><br><span class="line">(x:xs) ++ ys = x : xs ++ ys</span><br></pre></td></tr></table></figure>
<h1 id="List-II"><a href="#List-II" class="headerlink" title="List II"></a>List II</h1><h2 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h2><p>All functions take only one argument.</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">map</span> _ [] = []</span><br><span class="line"><span class="title">map</span> f (x:xs) = (f x) : map f xs</span><br></pre></td></tr></table></figure>
<h2 id="Tricks"><a href="#Tricks" class="headerlink" title="Tricks"></a>Tricks</h2><ul>
<li><p>Dot dot notation</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1.</span><span class="number">.4</span>] <span class="comment">--= [1,2,3,4]</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">4.</span><span class="number">.8</span>] <span class="comment">--= [2,4,6,8]</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">4.</span><span class="number">.1</span>] <span class="comment">--= [5,4,3,2,1]</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">3.</span><span class="number">.8</span>] <span class="comment">--= [1,3,5,7]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Infinite lists</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1.</span>.]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Lists-III"><a href="#Lists-III" class="headerlink" title="Lists III"></a>Lists III</h1><h2 id="Folds"><a href="#Folds" class="headerlink" title="Folds"></a>Folds</h2><ul>
<li><code>foldr</code><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldr</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line"><span class="title">foldr</span> f acc [] = acc</span><br><span class="line"><span class="title">foldr</span> f acc (x:xs) = f x (foldr f acc xs)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  :                         f</span><br><span class="line"> / \                       / \</span><br><span class="line">a   :       foldr f acc   a   f</span><br><span class="line">   / \    -------------&gt;     / \</span><br><span class="line">  b   :                     b   f</span><br><span class="line">     / \                       / \</span><br><span class="line">    c  []                     c   acc</span><br></pre></td></tr></table></figure>
<ul>
<li><code>foldl</code><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldl</span> :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</span><br><span class="line"><span class="title">foldl</span> f acc []     =  acc</span><br><span class="line"><span class="title">foldl</span> f acc (x:xs) =  foldl f (f acc x) xs</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  :                            f</span><br><span class="line"> / \                          / \</span><br><span class="line">a   :       foldl f acc      f   c</span><br><span class="line">   / \    -------------&gt;    / \</span><br><span class="line">  b   :                    f   b</span><br><span class="line">     / \                  / \</span><br><span class="line">    c  []                acc a</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>foldl</code> is <em>tail-recursive</em>, the compiler will optimise it to a loop. Becase of laziness, the calls to <code>f</code> will be left unevaluated, thus causing running tou of memory.</p>
</blockquote>
<ul>
<li><code>foldl&#39;</code>: forces the evaluation of <code>f</code> immediately at each step.</li>
</ul>
<blockquote>
<p>Use <code>foldr</code> on lists that might be infinite or where the fold is building up a data structure. Use <code>foldl&#39;</code> if the list is known to be finite and comes down to a single value.</p>
</blockquote>
<ul>
<li><p><code>foldr1</code> &amp; <code>foldl1</code>: taking the first element as default accumulator.</p>
<p> Types have to be the same, and an empty list is an error.</p>
</li>
</ul>
<h2 id="Folds-and-Laziness"><a href="#Folds-and-Laziness" class="headerlink" title="Folds and Laziness"></a>Folds and Laziness</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">echoes</span> = foldr (\ x xs -&gt; (replicate x x) ++ xs) []</span><br><span class="line"><span class="title">take</span> <span class="number">10</span> (echoes [<span class="number">1.</span>.])     <span class="comment">-- [1,2,2,3,3,3,4,4,4,4]</span></span><br><span class="line"></span><br><span class="line"><span class="title">echoes</span> = foldl (\ xs x -&gt; xs ++ (replicate x x)) []</span><br><span class="line"><span class="title">take</span> <span class="number">10</span> (echoes [<span class="number">1.</span>.])     <span class="comment">-- not terminating</span></span><br></pre></td></tr></table></figure>
<h2 id="Scans"><a href="#Scans" class="headerlink" title="Scans"></a>Scans</h2><p>Accumulates a values like a fold, and returns a list of all the intermediate values.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">scanl</span> :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a]</span><br></pre></td></tr></table></figure>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>Generates a new list composed of elements that meet a condition.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">filter</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br></pre></td></tr></table></figure>
<h2 id="List-comprehensions"><a href="#List-comprehensions" class="headerlink" title="List comprehensions"></a>List comprehensions</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">retainEven</span> es = [n | n &lt;- es, isEven n, ...condition]</span><br><span class="line"><span class="comment">&#123;-</span></span><br><span class="line"><span class="comment">1. n &lt;- es: take the list es and draw each element as value n.</span></span><br><span class="line"><span class="comment">2. isEven n: for each drawn n test the boolean condition.</span></span><br><span class="line"><span class="comment">3. n |: append n to the new list being created.</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">firstForEvenSeconds</span> ps = [x | (x, y) &lt;- ps, isEven y]</span><br><span class="line"><span class="title">allPairs</span> = [(x, y) | x &lt;- [<span class="number">1.</span><span class="number">.4</span>], y &lt;- [<span class="number">5.</span><span class="number">.8</span>]]</span><br></pre></td></tr></table></figure>
<h1 id="Type-declarations"><a href="#Type-declarations" class="headerlink" title="Type declarations"></a>Type declarations</h1><h2 id="data-and-constructor-functions"><a href="#data-and-constructor-functions" class="headerlink" title="data and constructor functions"></a><code>data</code> and constructor functions</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Anniversary</span> = <span class="type">Birthday</span> <span class="type">String</span> <span class="type">Int</span> <span class="type">Int</span> <span class="type">Int</span></span></span><br><span class="line">  | <span class="type">Wedding</span> <span class="type">String</span> <span class="type">String</span> <span class="type">Int</span> <span class="type">Int</span> <span class="type">Int</span></span><br></pre></td></tr></table></figure>
<p>Type names and constructor functions must start with captial letters.</p>
<h2 id="Deconstructing-types"><a href="#Deconstructing-types" class="headerlink" title="Deconstructing types"></a>Deconstructing types</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">showAnniversary</span> :: <span class="type">Anniversary</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">showAnniversary</span> (<span class="type">Birthday</span> name year month day) =</span><br><span class="line">   name ++ <span class="string">" born "</span> ++ showDate year month day</span><br><span class="line"><span class="title">showAnniversary</span> (<span class="type">Wedding</span> name1 name2 year month day) =</span><br><span class="line">   name1 ++ <span class="string">" married "</span> ++ name2 ++ <span class="string">" on "</span> ++ showDate year month day</span><br></pre></td></tr></table></figure>
<h2 id="Type-synonyms"><a href="#Type-synonyms" class="headerlink" title="Type synonyms"></a>Type synonyms</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Name</span> = <span class="type">String</span></span></span><br></pre></td></tr></table></figure>
<h1 id="Pattern-matching"><a href="#Pattern-matching" class="headerlink" title="Pattern matching"></a>Pattern matching</h1><p>In pattern matching, we attempte to <strong>match</strong> values against <strong>patterns</strong> and <strong>bind</strong> variables to successful matches.</p>
<ul>
<li>Constructors are allowed in patterns.</li>
<li><code>[]</code> &amp; <code>(:)</code> are constructors of the list.</li>
<li>tuple constructors: <code>(,)</code>, <code>(,,)</code>…<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(,) <span class="number">5</span> <span class="number">3</span> <span class="comment">--&gt; (5,3)</span></span><br><span class="line">(,,) <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="comment">--&gt; (1,2,3)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Matching-literal-values"><a href="#Matching-literal-values" class="headerlink" title="Matching literal values"></a>Matching literal values</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">g</span> :: [<span class="type">Int</span>] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">g</span> (<span class="number">0</span>:[]) = <span class="type">False</span></span><br><span class="line"><span class="title">g</span> (<span class="number">0</span>:xs) = <span class="type">True</span></span><br><span class="line"><span class="title">g</span> _ = <span class="type">False</span></span><br></pre></td></tr></table></figure>
<h2 id="Syntax-tricks"><a href="#Syntax-tricks" class="headerlink" title="Syntax tricks"></a>Syntax tricks</h2><h3 id="As-patterns"><a href="#As-patterns" class="headerlink" title="As-patterns"></a>As-patterns</h3><p>Binds a name to the whold value being matched: <code>var@pattern</code>.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">contrivedMap</span> :: ([a] -&gt; a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">contrivedMap</span> f [] = []</span><br><span class="line"><span class="title">contrivedMap</span> f list@(x:xs) = f list x : contrivedMap f xs</span><br></pre></td></tr></table></figure>
<h3 id="Records"><a href="#Records" class="headerlink" title="Records"></a>Records</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Foo2</span> = <span class="type">Bar2</span> | <span class="type">Baz2</span> &#123;<span class="title">bazNumber</span>::<span class="type">Int</span>, <span class="title">bazName</span>::<span class="type">String</span>&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">h</span> :: <span class="type">Foo2</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">h</span> <span class="type">Baz2</span> &#123;bazName=name&#125; = length name</span><br><span class="line"><span class="title">h</span> <span class="type">Bar2</span> &#123;&#125; = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="title">x</span> = <span class="type">Baz2</span> <span class="number">1</span> <span class="string">"Haskell"</span>     <span class="comment">-- construct by declaration order, try ":t Baz2" in GHCi</span></span><br><span class="line"><span class="title">y</span> = <span class="type">Baz2</span> &#123;bazName = <span class="string">"Curry"</span>, bazNumber = <span class="number">2</span>&#125; <span class="comment">-- construct by name</span></span><br><span class="line"></span><br><span class="line"><span class="title">h</span> x <span class="comment">-- 7</span></span><br><span class="line"><span class="title">h</span> y <span class="comment">-- 5</span></span><br></pre></td></tr></table></figure>
<p>Also, the <code>{}</code> pattern can be used for matching a constructor regardless of the datatype elements</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Foo</span> = <span class="type">Bar</span> | <span class="type">Baz</span> <span class="type">Int</span></span></span><br><span class="line"><span class="title">g</span> :: <span class="type">Foo</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">g</span> <span class="type">Bar</span> &#123;&#125; = <span class="type">True</span></span><br><span class="line"><span class="title">g</span> <span class="type">Baz</span> &#123;&#125; = <span class="type">False</span></span><br></pre></td></tr></table></figure>
<h2 id="Where-pattern-matching-can-be-used"><a href="#Where-pattern-matching-can-be-used" class="headerlink" title="Where pattern matching can be used"></a>Where pattern matching can be used</h2><ul>
<li>Equations</li>
<li><code>let</code> &amp; <code>where</code></li>
<li>Lambda asbstractions</li>
<li><p>List comprehensions</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data Maybe a = Nothing | Just a</span><br><span class="line"></span><br><span class="line">catMaybes :: [Maybe a] -&gt; [a]</span><br><span class="line">catMaybes ms = [ x | Just x &lt;- ms ]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>do</code> blocks</p>
</li>
</ul>
<h1 id="Control-structures"><a href="#Control-structures" class="headerlink" title="Control structures"></a>Control structures</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">if</span> &lt;condition&gt; <span class="keyword">then</span> &lt;true-value&gt; <span class="keyword">else</span> &lt;false-value&gt;</span><br></pre></td></tr></table></figure>
<p><code>if</code> is an expression, and <code>else</code>is mandatory.</p>
<p><code>if</code> can be embedding:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">g</span> x y = (<span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> sin x / x) * y</span><br></pre></td></tr></table></figure></p>
<h2 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> (pattern1) | predicate1 = w</span><br><span class="line">             | predicate2 = x</span><br><span class="line">             | otherwise = z</span><br></pre></td></tr></table></figure>
<p><code>otherwise</code> is jst an alias to <code>True</code>.</p>
<h2 id="case"><a href="#case" class="headerlink" title="case"></a><code>case</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f x =</span><br><span class="line">    case x of</span><br><span class="line">        0 -&gt; 18</span><br><span class="line">        1 -&gt; 15</span><br><span class="line">        2 -&gt; 12</span><br><span class="line">        _ -&gt; 12 - x</span><br></pre></td></tr></table></figure>
<h2 id="Controlling-actions"><a href="#Controlling-actions" class="headerlink" title="Controlling actions"></a>Controlling actions</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doGuessing</span> num = <span class="keyword">do</span></span><br><span class="line">   putStrLn <span class="string">"Enter your guess:"</span></span><br><span class="line">   guess &lt;- getLine</span><br><span class="line">   <span class="keyword">if</span> (read guess) &lt; num</span><br><span class="line">     <span class="keyword">then</span> <span class="keyword">do</span> putStrLn <span class="string">"Too low!"</span></span><br><span class="line">             doGuessing num</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (read guess) &gt; num</span><br><span class="line">            <span class="keyword">then</span> <span class="keyword">do</span> putStrLn <span class="string">"Too high!"</span></span><br><span class="line">                    doGuessing num</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">do</span> putStrLn <span class="string">"You Win!"</span></span><br><span class="line"></span><br><span class="line"><span class="title">doGuessing</span> num = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">"Enter your guess:"</span></span><br><span class="line">  guess &lt;- getLine</span><br><span class="line">  <span class="keyword">case</span> compare (read guess) num <span class="keyword">of</span></span><br><span class="line">    <span class="type">LT</span> -&gt; <span class="keyword">do</span> putStrLn <span class="string">"Too low!"</span></span><br><span class="line">             doGuessing num</span><br><span class="line">    <span class="type">GT</span> -&gt; <span class="keyword">do</span> putStrLn <span class="string">"Too high!"</span></span><br><span class="line">             doGuessing num</span><br><span class="line">    <span class="comment">-- the dos after the -&gt;s are necessary because of sequencing actions.</span></span><br><span class="line">    <span class="type">EQ</span> -&gt; putStrLn <span class="string">"You Win!"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>A note about <code>return</code></p>
<p><code>return</code> is not equivalent to other language, <code>return ()</code> evaluates to an action which does nothing.</p>
</blockquote>
<h1 id="More-on-functions"><a href="#More-on-functions" class="headerlink" title="More on functions"></a>More on functions</h1><h2 id="let-and-where"><a href="#let-and-where" class="headerlink" title="let and where"></a><code>let</code> and <code>where</code></h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addStr</span> :: <span class="type">Float</span> -&gt; <span class="type">String</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">addStr</span> x str = x + read str</span><br><span class="line"></span><br><span class="line"><span class="title">sumStr</span> :: [<span class="type">String</span>] -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">sumStr</span> = foldl addStr <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- with let</span></span><br><span class="line"><span class="title">sumStr</span> =</span><br><span class="line">   <span class="keyword">let</span> addStr x str = x + read str</span><br><span class="line">   <span class="keyword">in</span> foldl addStr <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- with where</span></span><br><span class="line"><span class="title">sumStr</span> = foldl addStr <span class="number">0.0</span></span><br><span class="line">   <span class="keyword">where</span> addStr x str = x + read str</span><br></pre></td></tr></table></figure>
<p><code>let</code> is an expression, <code>where</code> are like guards and are not expressions. <code>let</code> bindings can be used within complex expressions.</p>
<p><code>where</code> can be incorporated into <code>case</code> expressions and guards:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">describeColour</span> c =</span><br><span class="line">   <span class="string">"This colour "</span></span><br><span class="line">   ++ <span class="keyword">case</span> c <span class="keyword">of</span></span><br><span class="line">          <span class="type">Black</span> -&gt; <span class="string">"is black"</span></span><br><span class="line">          <span class="type">White</span> -&gt; <span class="string">"is white"</span></span><br><span class="line">          <span class="type">RGB</span> red green blue -&gt; <span class="string">" has an average of the components of "</span> ++ show av</span><br><span class="line">             <span class="comment">-- only available for RGB</span></span><br><span class="line">             <span class="keyword">where</span> av = (red + green + blue) `div` <span class="number">3</span></span><br><span class="line">   ++ <span class="string">", yeah?"</span></span><br><span class="line"></span><br><span class="line"><span class="title">doStuff</span> :: <span class="type">Int</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">doStuff</span> x</span><br><span class="line">  | x &lt; <span class="number">3</span>     = report <span class="string">"less than three"</span></span><br><span class="line">  | otherwise = report <span class="string">"normal"</span></span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    report y = <span class="string">"the input is "</span> ++ y</span><br></pre></td></tr></table></figure></p>
<h2 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sumStr</span> = foldl (\ x str -&gt; x + read str) <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><p>All function that takes two arguments and has a name consisting entirely of non-alphanumeric characters is considered an operator.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">4</span></span><br><span class="line">(+) <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(\\) :: (<span class="type">Eq</span> a) =&gt; [a] -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">xs</span> \\ ys = foldl (\zs y -&gt; delete y zs) xs ys</span><br><span class="line"></span><br><span class="line">(\\) xs ys = foldl (\zs y -&gt; delete y zs) xs ys</span><br></pre></td></tr></table></figure>
<h3 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">2</span>+) <span class="number">4</span></span><br><span class="line">(+<span class="number">4</span>) <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="“normal”-prefix"><a href="#“normal”-prefix" class="headerlink" title="“normal” prefix"></a>“normal” prefix</h3><p>Use function as a operator:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">elem</span> :: (<span class="type">Eq</span> a) =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">x</span> `elem` xs = any (==x) xs</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> `elem` [<span class="number">1.</span><span class="number">.4</span>]</span><br></pre></td></tr></table></figure></p>
<h1 id="Higher-order-functions"><a href="#Higher-order-functions" class="headerlink" title="Higher-order functions"></a>Higher-order functions</h1><h2 id="Ord"><a href="#Ord" class="headerlink" title="Ord"></a><code>Ord</code></h2><p>Almost all basic data types are members of the <code>Ord</code> class， which is for ordering tests.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">compare</span> :: (<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; <span class="type">Ordering</span></span><br><span class="line"><span class="type">Ordering</span> = <span class="type">LT</span> | <span class="type">EQ</span> | <span class="type">GT</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>-&gt;</code> is right-associative.</li>
</ul>
<h2 id="Function-manipulation"><a href="#Function-manipulation" class="headerlink" title="Function manipulation"></a>Function manipulation</h2><ol>
<li><p>Flipping arguments: <code>flip</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">flip</span> :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</span><br></pre></td></tr></table></figure>
</li>
<li><p>Composition： <code>(.)</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt;c</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- myInits [1,2,3] -&gt; [[], [1,2], [1,2,3]]</span></span><br><span class="line"><span class="title">myInits</span> :: [a] -&gt; [[a]]</span><br><span class="line"><span class="title">myInits</span> = map reverse . scanl (flip (:)) []</span><br></pre></td></tr></table></figure>
<ol>
<li>Application: <code>($)</code><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($) :: (a -&gt; b) -&gt; a -&gt; b</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><code>$</code> has very low precedence.</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> ($ <span class="number">2</span>) [(<span class="number">2</span>*), (<span class="number">4</span>*), (<span class="number">8</span>*)]</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>curry</code> &amp; <code>uncurry</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">curry</span> :: ((a, b) -&gt; c) -&gt; a -&gt; b -&gt; c</span><br><span class="line"><span class="title">uncurry</span> :: (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the first element of a paire is applied to the second</span></span><br><span class="line"><span class="title">uncurry</span> ($) (reverse, <span class="string">"stressed"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>id</code> &amp; <code>const</code></p>
</li>
</ol>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- return its argument unchanged</span></span><br><span class="line"><span class="title">id</span> :: a -&gt; a</span><br><span class="line"><span class="comment">-- discards the second and return the first</span></span><br><span class="line"><span class="title">const</span> :: a -&gt; b -&gt; a</span><br></pre></td></tr></table></figure>
<h1 id="Using-GHCi-effectively"><a href="#Using-GHCi-effectively" class="headerlink" title="Using GHCi effectively"></a>Using GHCi effectively</h1><h2 id="Tab-completion"><a href="#Tab-completion" class="headerlink" title="Tab completion"></a>Tab completion</h2><h2 id="commands"><a href="#commands" class="headerlink" title=":commands"></a><code>:commands</code></h2><ul>
<li><code>:h[elp]</code></li>
<li><code>:l[oad]</code></li>
<li><code>:r[eload]</code></li>
<li><code>:t[ype]</code></li>
<li><code>:m[odule]</code></li>
<li><code>:b[rowse]</code></li>
</ul>
<h2 id="Timing-funcitions"><a href="#Timing-funcitions" class="headerlink" title="Timing funcitions"></a>Timing funcitions</h2><p>The basic way to measure how much a function takes to run. Run <code>:set + s</code> then run the functions that are tested.</p>
<h2 id="Multi-line-input"><a href="#Multi-line-input" class="headerlink" title="Multi-line input"></a>Multi-line input</h2><p>Surrounded code with <code>:{</code> <code>:}</code>.</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-06-18</span><i class="fa fa-comment-o"></i><a href="/en/2018/06/18/haskell-wiki-reading-notes-2/#comments">Comments</a><i class="fa fa-tag"></i><a class="tag" href="/tags/haskell/" title="haskell">haskell </a><a class="tag" href="/tags/notes/" title="notes">notes </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://mondogao.github.io/en/2018/06/18/haskell-wiki-reading-notes-2/,麦冬,Haskell Wiki Reading Notes 2 - Elementary,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/en/2018/04/29/haskell-wiki-reading-notes-1/" title="Haskell Wiki Reading Notes 1 - Basic">next_post</a></li></ul></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'mondogao';
var disqus_identifier = 'en/2018/06/18/haskell-wiki-reading-notes-2/';
var disqus_title = 'Haskell Wiki Reading Notes 2 - Elementary';
var disqus_url = 'https://mondogao.github.io/en/2018/06/18/haskell-wiki-reading-notes-2/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>