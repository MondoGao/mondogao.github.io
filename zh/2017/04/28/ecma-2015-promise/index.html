<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Mondo Gao"><title>ES2015 标准 Promise 深入理解：实现 · 麦冬</title><meta name="description" content="前言本文以 ECMA-262 标准中 Promise 部分为参考，利用 ES6 语法对 Promise 进行实现，读完本文应能提升对 Promise 内部机制的了解，前提是已经对 Promise 用法有一定了解，本文不再赘述。
名词定义此处定义在下方实现中出现的一系列名词的简单解释
构造函数名本文为"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><h3 title=""><a href="/">麦冬</a></h3><div class="description"><p>前端、杂谈、设计、艺术。</p></div></div></div><ul class="social-links"><li><a href="mailto:mondogao@gmail.com?Subject=交个朋友吧！"><i class="fa fa-envelope"></i></a></li><li><a href="http://weibo.com/MondoGao"><i class="fa fa-weibo"></i></a></li><li><a href="https://twitter.com/mondo_gao"><i class="fa fa-twitter"></i></a></li><li><a href="http://facebook.com/MondoGao"><i class="fa fa-facebook"></i></a></li><li><a href="http://instagram.com/mondogao"><i class="fa fa-instagram"></i></a></li><li><a href="http://github.com/mondogao"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><div class="by_farbox"><a href="https://hexo.io/" target="_blank">Powered by Hexo</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="https://www.gravatar.com/avatar/ef6553e3101c4dd8130672b2332a7472"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>ES2015 标准 Promise 深入理解：实现</a></h3></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文以 ECMA-262 标准中 Promise 部分为参考，利用 ES6 语法对 Promise 进行实现，读完本文应能提升对 Promise 内部机制的了解，前提是已经对 Promise 用法有一定了解，本文不再赘述。</p>
<h2 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h2><p>此处定义在下方实现中出现的一系列名词的简单解释</p>
<h3 id="构造函数名"><a href="#构造函数名" class="headerlink" title="构造函数名"></a>构造函数名</h3><p>本文为了防止冲突，使用 MPromise 作为构造函数名（M 就是 Mondo 啦~）</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><h4 id="Promise-自身状态"><a href="#Promise-自身状态" class="headerlink" title="Promise 自身状态"></a>Promise 自身状态</h4><ul>
<li>fulfilled<br>已经被解决的状态，在此状态下调用 then(onFulfilled, onRejected) 将会直接调用 onFulfilled 函数</li>
<li>rejected<br>类似 fulfilled 状态，但调用的是 onRejected</li>
<li>pending<br>既不处于 fulfilled 也不处于 rejected 的状态</li>
</ul>
<h4 id="衍生状态"><a href="#衍生状态" class="headerlink" title="衍生状态"></a>衍生状态</h4><ol>
<li><p>settled<br>处于 fulfilled 或 rejected 状态</p>
</li>
<li><p>resolved<br> 处于 settled 状态或处于无法通过 resolve / reject 函数改变状态的状态</p>
<blockquote>
<p>在阮一峰第二版 ES6 入门中混淆了 resolved 状态和 fulfilled 状态，此处解释遵循  ECMA-262 标准中解释</p>
</blockquote>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">new</span> MPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(resolve, <span class="number">1000</span>, <span class="string">'inside'</span>)</span><br><span class="line">  &#125;) <span class="comment">// =&gt; 返回 promise-1 对象</span></span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// promise-1 进入 resolved 状态，但其自身 state 仍处于 pending</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">1000</span>, <span class="string">'second inside'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;) <span class="comment">// =&gt; 返回 promise-2 对象</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><h4 id="executor"><a href="#executor" class="headerlink" title="executor"></a>executor</h4><p>传入构造函数中的函数，接受 resolve 和 reject 函数作为参数</p>
<h4 id="resolve-amp-reject"><a href="#resolve-amp-reject" class="headerlink" title="resolve &amp; reject"></a>resolve &amp; reject</h4><p>用于传入 executor 中，或用于 resolve / reject 处于 resolved 锁定状态的 promise</p>
<h4 id="onFulfilled-amp-onRejected-handler"><a href="#onFulfilled-amp-onRejected-handler" class="headerlink" title="onFulfilled &amp; onRejected (handler)"></a>onFulfilled &amp; onRejected (handler)</h4><p>传入 then 函数中的函数，一般为用户外部定义，在 promise 状态处于 settled 时会按顺序被调用，其中的返回值将作为 then 创建的新 promise 的 result</p>
<blockquote>
<p>一个非用户定义的例子为在这两个函数返回新的内部 promise 时，将 then 新建的传递给外部的 promise 的 resolve &amp; reject 函数作为内部 promise 的 onFulfilled &amp; onRejected 函数</p>
</blockquote>
<h3 id="特殊封装对象"><a href="#特殊封装对象" class="headerlink" title="特殊封装对象"></a>特殊封装对象</h3><h4 id="PromiseCapability"><a href="#PromiseCapability" class="headerlink" title="PromiseCapability"></a>PromiseCapability</h4><p>一组 promise 和改变该 promise 状态函数的封装对象，结构如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  promise,</span><br><span class="line">  resolve,</span><br><span class="line">  reject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PromiseReaction"><a href="#PromiseReaction" class="headerlink" title="PromiseReaction"></a>PromiseReaction</h4><p>一组对 capability 和 handler 的封装，结构如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  capabilities,</span><br><span class="line">  handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通用函数及常量"><a href="#通用函数及常量" class="headerlink" title="通用函数及常量"></a>通用函数及常量</h2><p>该部分函数为不包含在 Promise 部分的抽象操作，此处处理为函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个 Promise 所处的状态</span></span><br><span class="line"><span class="comment"> * @const</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> states = &#123;</span><br><span class="line">  PENDING: <span class="string">'pending'</span>,</span><br><span class="line">  FULFILLED: <span class="string">'fulfilled'</span>,</span><br><span class="line">  REJECTED: <span class="string">'rejected'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 特殊的两种处理函数</span></span><br><span class="line"><span class="comment"> * @const</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> handlerType = &#123;</span><br><span class="line">  IDENTITY: <span class="string">'Identity'</span>,</span><br><span class="line">  THROUER: <span class="string">'Thrower'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个变量是否可以被调用</span></span><br><span class="line"><span class="comment"> * @param executor</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isCallable</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> executor === <span class="string">'function'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个变量是否可以当作构造函数调用，此处因无较好方法直接判断是否为函数</span></span><br><span class="line"><span class="comment"> * @param arg</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isConstructor</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> arg === <span class="string">'function'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个变量是否为 Promise，按标准实现</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">'object'</span> &amp;&amp; x.promiseState !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将传递来的函数加入队列</span></span><br><span class="line"><span class="comment"> * @param queueName - 可被 js 引擎识别的队列名称，此处忽略</span></span><br><span class="line"><span class="comment"> * @param job - 任务函数</span></span><br><span class="line"><span class="comment"> * @param argumentArr - 传递给 job 的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueJob</span>(<span class="params">queueName, job, ...argumentArr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 断言： argumentArr 的 length 和函数的 length 一致</span></span><br><span class="line">  setTimeout(job, <span class="number">0</span>, ...argumentArr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数、实例方法及相关操作"><a href="#构造函数、实例方法及相关操作" class="headerlink" title="构造函数、实例方法及相关操作"></a>构造函数、实例方法及相关操作</h2><h4 id="Promise-executor"><a href="#Promise-executor" class="headerlink" title="Promise(executor)"></a>Promise(executor)</h4><p>按 ES6 标准，该构造函数必须通过 new 关键字实例化，并且支持继承。</p>
<p>当 Promise 被调用时，代码和流程如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="comment">// 1. 如果该函数不是被 new 关键字调用，抛出 TypeError 错误</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 如果 executor 不是一个函数，抛出 TypeError 错误</span></span><br><span class="line">    <span class="keyword">if</span> (!isCallable(executor)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 创建 Promise 实例的属性</span></span><br><span class="line">    <span class="keyword">this</span>.promiseState = states.PENDING</span><br><span class="line">    <span class="keyword">this</span>.promiseResult = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.promiseFulfillReactions = []</span><br><span class="line">    <span class="keyword">this</span>.promiseRejectReactions = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 获取用于传入 executor 的 resolve 和 reject 方法，createResolvingFunctions 见下文</span></span><br><span class="line">    <span class="keyword">let</span> resolvingFunctions = createResolvingFunctions(<span class="keyword">this</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 5. 调用 executor 函数，并传入刚刚创建的 resolve 和 reject 方法，如出错则以调用函数的结果 reject 这个 promise</span></span><br><span class="line">    <span class="keyword">let</span> completion = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      completion = executor.call(<span class="literal">undefined</span>, resolvingFunctions.resolve, resolvingFunctions.reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      resolvingFunctions.reject.call(<span class="literal">undefined</span>, completion)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="CreateResolvingFunctions-promise"><a href="#CreateResolvingFunctions-promise" class="headerlink" title="CreateResolvingFunctions(promise)"></a>CreateResolvingFunctions(promise)</h4><p>该函数用于创建与 promise 绑定的两个 resolve、reject 方法，这两个方法用于传入 executor 中，其流程如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 promise 创建 resolve 和 reject 并将其与 promise 绑定</span></span><br><span class="line"><span class="comment"> * @param promise</span></span><br><span class="line"><span class="comment"> * @return &#123;&#123;resolve: function, reject: function&#125;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createResolvingFunctions</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 创建是否已调用过 resolve、reject 的标识，为了保证同一使用对象来进行传递；该状态实质上与 promise 一对一绑定，标识是否进入 resolved 状态</span></span><br><span class="line">  <span class="keyword">let</span> alreadyResolved = &#123;</span><br><span class="line">    value: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 创建 resolve 方法</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * resolve 方法</span></span><br><span class="line"><span class="comment">   * @type &#123;PromiseResolveFunctions&#125;</span></span><br><span class="line"><span class="comment">   * @param resolution</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> resolve = <span class="function"><span class="keyword">function</span> (<span class="params">resolution</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 断言： resolve 在调用时已绑定 promise</span></span><br><span class="line">    <span class="keyword">let</span> promise = resolve.promise</span><br><span class="line">    <span class="keyword">let</span> alreadyResolved = resolve.alreadyResolved</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 忽略重复调用</span></span><br><span class="line">    <span class="keyword">if</span> (alreadyResolved.value) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 将 promise 标记为 resolved</span></span><br><span class="line">    alreadyResolved.value = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 禁止在 resolve 时传入原本的 promise，若传入，直接 reject 这个 promise</span></span><br><span class="line">    <span class="keyword">if</span> (promise === resolution) &#123;</span><br><span class="line">      <span class="keyword">let</span> selfResolutionError = <span class="keyword">new</span> <span class="built_in">TypeError</span>()</span><br><span class="line">      <span class="keyword">return</span> rejectPromise(promise,  selfResolutionError)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 如果传入的是一个普通的值，直接用该值 fulfill 该 promise</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> resolution !== <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fulfillPromise(promise, resolution)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 如果传入的是一个对象，则获取其 #then 方法</span></span><br><span class="line">    <span class="keyword">let</span> then = resolution.then</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7. 若 then 方法不存在或不是函数，则直接用该值 fulfill 该 promise</span></span><br><span class="line">    <span class="keyword">if</span> (!isCallable(then)) &#123;</span><br><span class="line">      <span class="keyword">return</span> fulfillPromise(promise, resolution)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 8. 将 promise 和新的 thenable 对象（通常为 promise）传入队列中</span></span><br><span class="line">    enqueueJob(<span class="string">'PromiseJobs'</span>, promiseResolveThenableJob, ...[promise, resolution, then])</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 将 resolve 方法与 promise 绑定，间接绑定 resolved 状态</span></span><br><span class="line">  resolve.promise = promise</span><br><span class="line">  resolve.alreadyResolved = alreadyResolved</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4. 创建 reject 方法，并与 promise 绑定</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * reject 方法</span></span><br><span class="line"><span class="comment">   * @type &#123;PromiseRejectFunctions&#125;</span></span><br><span class="line"><span class="comment">   * @param reason</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> reject = <span class="function"><span class="keyword">function</span> <span class="title">promiseReject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 该方法与 resolve 方法类似，考虑情况更少更简单一些</span></span><br><span class="line">    <span class="keyword">let</span> promise = reject.promise</span><br><span class="line">    <span class="keyword">let</span> alreadyResolved = reject.alreadyResolved</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (alreadyResolved) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    alreadyResolved.value = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rejectPromise(promise, reason)</span><br><span class="line">  &#125;</span><br><span class="line">  reject.promise = promise</span><br><span class="line">  reject.alreadyResolved = alreadyResolved</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    resolve,</span><br><span class="line">    reject</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FulfillPromise-promise-reason-amp-RejectPromise-promise-reason"><a href="#FulfillPromise-promise-reason-amp-RejectPromise-promise-reason" class="headerlink" title="FulfillPromise(promise, reason) &amp; RejectPromise(promise, reason)"></a>FulfillPromise(promise, reason) &amp; RejectPromise(promise, reason)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的值 fulfill 一个 promise</span></span><br><span class="line"><span class="comment"> * @param promise</span></span><br><span class="line"><span class="comment"> * @param value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> fulfillPromise = <span class="function">(<span class="params">promise, value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 断言： promise 处于 pending 状态</span></span><br><span class="line">  <span class="comment">// 2. 取出 promise 中的待处理动作并将其状态改为 fulfilled</span></span><br><span class="line">  <span class="keyword">let</span> reactions = promise.promiseFulfillReactions</span><br><span class="line">  promise.promiseResult = value</span><br><span class="line">  promise.promiseFulfillReactions = <span class="literal">undefined</span></span><br><span class="line">  promise.promiseRejectReactions = <span class="literal">undefined</span></span><br><span class="line">  promise.promiseState = states.FULFILLED</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 将待处理动作加入队列中</span></span><br><span class="line">  <span class="keyword">return</span> triggerPromiseReactions(reactions, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的原因 reject 一个 promise，类似 fulfillPromise</span></span><br><span class="line"><span class="comment"> * @param promise</span></span><br><span class="line"><span class="comment"> * @param reason</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rejectPromise</span>(<span class="params">promise, reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reactions = promise.promiseRejectReactions</span><br><span class="line">  promise.promiseResult = reason</span><br><span class="line">  promise.promiseFulfillReactions = <span class="literal">undefined</span></span><br><span class="line">  promise.promiseRejectReactions = <span class="literal">undefined</span></span><br><span class="line">  promise.promiseState = states.REJECTED</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> triggerPromiseReactions(reactions, reason)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TriggerPromiseReactions-reactions-argument-amp-PromiseReactionJob-reaction-argument"><a href="#TriggerPromiseReactions-reactions-argument-amp-PromiseReactionJob-reaction-argument" class="headerlink" title="TriggerPromiseReactions(reactions, argument) &amp; PromiseReactionJob(reaction, argument)"></a>TriggerPromiseReactions(reactions, argument) &amp; PromiseReactionJob(reaction, argument)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将接收到的待处理事物加入队列</span></span><br><span class="line"><span class="comment"> * @param &#123;PromiseReactionRecords&#125; reactions</span></span><br><span class="line"><span class="comment"> * @param argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">triggerPromiseReactions</span>(<span class="params">reactions, argument</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> reaction <span class="keyword">of</span> reactions) &#123;</span><br><span class="line">    enqueueJob(<span class="string">'PromiseJobs'</span>, promiseReactionJob, ...[reaction, argument])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用传入的 argument 的值对 promise 进行 fulfill 或 reject</span></span><br><span class="line"><span class="comment"> * @param reaction</span></span><br><span class="line"><span class="comment"> * @param argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseReactionJob</span>(<span class="params">reaction, argument</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 断言： reaction 是一个包含 capability 和 handler 的对象，该对象在 then 中被创建，见下文；handler 为向 then 中传递的 onFulfilled 或 onRejected 函数</span></span><br><span class="line">  <span class="keyword">let</span> promiseCapability = reaction.capabilities</span><br><span class="line">  <span class="keyword">let</span> handler = reaction.handler</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 对于特殊 handler 的处理，Identity 和 Thrower 都不对 argument 进行处理</span></span><br><span class="line">  <span class="keyword">let</span> handlerResult = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler === handlerType.IDENTITY) &#123;</span><br><span class="line">      handlerResult = argument</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler === handlerType.THROUER) &#123;</span><br><span class="line">      <span class="keyword">throw</span> argument</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handlerResult = handler.call(<span class="literal">undefined</span>, argument)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> promiseCapability.reject.call(<span class="literal">undefined</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> promiseCapability.resolve.call(<span class="literal">undefined</span>, handlerResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PromiseResolveThenableJob-promiseToResolve-thenable-then"><a href="#PromiseResolveThenableJob-promiseToResolve-thenable-then" class="headerlink" title="PromiseResolveThenableJob(promiseToResolve, thenable, then)"></a>PromiseResolveThenableJob(promiseToResolve, thenable, then)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受一个还未被 resolve 的 promise，进行异步的处理</span></span><br><span class="line"><span class="comment"> * @param promiseToResolve - 由该 promsie 的 resolve 函数传递来</span></span><br><span class="line"><span class="comment"> * @param thenable - 原 promise resolve 函数接收到的内部 promise</span></span><br><span class="line"><span class="comment"> * @param then - thenble 的 then 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseResolveThenableJob</span>(<span class="params">promiseToResolve, thenable, then</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 重新给 promise 绑定 resolve 和 reject 方法，因为传递来的 promise 一定没有被 resolve</span></span><br><span class="line">  <span class="keyword">let</span> resolvingFunctions = createResolvingFunctions(promiseToResolve)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 完成 handler 内部返回 promise 后的传递的核心逻辑，将外部 promise 的 resolve，reject 方法传入到内部 promise 的 then 函数中</span></span><br><span class="line">  <span class="keyword">let</span> thenCallResult = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    thenCallResult = then.call(thenable, ...[resolvingFunctions.resolve, resolvingFunctions.reject])</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolvingFunctions.reject.call(<span class="literal">undefined</span>, ...[err])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Promise-then-amp-PerformPromiseThen-promise-onFulfilled-onRejected-resultCapability"><a href="#Promise-then-amp-PerformPromiseThen-promise-onFulfilled-onRejected-resultCapability" class="headerlink" title="Promise#then &amp; PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability)"></a>Promise#then &amp; PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability)</h4><p>then 作为 Promise 的核心方法，是 Promise 解决回调嵌套和精髓之处，本文的实例方法也只暂包含这一个方法。通过该方法可轻松实现 <code>Promise#catch</code> 等其他一系列实例或类方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 如果 this 指向的不是一个 promise 则报错</span></span><br><span class="line">  <span class="keyword">if</span> (!isPromise(promise)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 获取 promise 的 constructor 以保证调用子类的构造函数</span></span><br><span class="line">  <span class="keyword">let</span> C = promise.constructor</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 将该构造函数传入，返回一个 capability 对象；相当于同时完成了实例化和 resolve，reject 函数绑定</span></span><br><span class="line">  <span class="keyword">let</span> resultCapability = newPromiseCapability(C)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> performPromiseThen(promise, onFulfilled, onRejected, resultCapability)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * then 函数核心逻辑</span></span><br><span class="line"><span class="comment"> * @param promise - 调用 then 的原 promise</span></span><br><span class="line"><span class="comment"> * @param onFulfilled</span></span><br><span class="line"><span class="comment"> * @param onRejected</span></span><br><span class="line"><span class="comment"> * @param resultCapability - 新建的 promiseCapability，包含新 promise 和对应的 resolve，reject 函数</span></span><br><span class="line"><span class="comment"> * @return &#123;MPromise&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performPromiseThen</span>(<span class="params">promise, onFulfilled, onRejected, resultCapability</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 断言： 传入的 promise 是一个 promise 实例</span></span><br><span class="line">  <span class="comment">// 2. 断言： 传入的 resultCapability 包含 promise 和其对应的 resolve，reject 函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 如果 onFuilfilled，onRejected 不是一个函数，将其标记为特殊函数类型</span></span><br><span class="line">  <span class="keyword">if</span> (!isCallable(onFulfilled)) &#123;</span><br><span class="line">    onFulfilled = handlerType.IDENTITY</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isCallable(onRejected)) &#123;</span><br><span class="line">    onRejected = handlerType.THROUER</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4. 创建可被 promiseReactionJob 处理的行为对象</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @type &#123;PromiseReactionRecords&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> fulfillReaction = &#123;</span><br><span class="line">    capabilities: resultCapability,</span><br><span class="line">    handler: onFulfilled</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> rejectReaction = &#123;</span><br><span class="line">    capabilities: resultCapability,</span><br><span class="line">    handler: onRejected</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 5. 根据原 promise 的状态将上方行为加入到其相应队列中</span></span><br><span class="line">  <span class="keyword">switch</span> (promise.promiseState) &#123;</span><br><span class="line">    <span class="keyword">case</span> states.PENDING:</span><br><span class="line">      promise.promiseFulfillReactions.push(fulfillReaction)</span><br><span class="line">      promise.promiseRejectReactions.push(rejectReaction)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> states.FULFILLED:</span><br><span class="line">      <span class="keyword">let</span> value = promise.promiseResult</span><br><span class="line">      enqueueJob(<span class="string">'PromiseJobs'</span>, promiseReactionJob, ...[fulfillReaction, value])</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> states.REJECTED:</span><br><span class="line">      <span class="keyword">let</span> reason = promise.promiseResult</span><br><span class="line">      enqueueJob(<span class="string">'PromiseJobs'</span>, promiseReactionJob, ...[rejectReaction, reason])</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 6. 返回新的 promise</span></span><br><span class="line">  <span class="keyword">return</span> resultCapability.promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NewPromiseCapability-C"><a href="#NewPromiseCapability-C" class="headerlink" title="NewPromiseCapability(C)"></a>NewPromiseCapability(C)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据传入的构造函数构造新的 promsie 并获取到在构造函数中绑定的 resolve，reject 方法</span></span><br><span class="line"><span class="comment"> * @param C - promise 构造函数</span></span><br><span class="line"><span class="comment"> * @return &#123;&#123;promise, resolve, reject&#125;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newPromiseCapability</span>(<span class="params">C</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 如果 C 不是一个构造函数则报错</span></span><br><span class="line">  <span class="keyword">if</span> (!isConstructor(C)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 创建要返回的一体化对象</span></span><br><span class="line">  <span class="keyword">let</span> promiseCapability = &#123;</span><br><span class="line">    promise: <span class="literal">undefined</span>,</span><br><span class="line">    resolve: <span class="literal">undefined</span>,</span><br><span class="line">    reject: <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 创建传入构造函数中的函数，目的是获取 resolve 和 reject 方法</span></span><br><span class="line">  <span class="keyword">let</span> executor = <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 断言： executor 函数属性中存在 对 promiseCapability 的引用</span></span><br><span class="line">    <span class="keyword">let</span> promiseCapability = executor.capability</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (promiseCapability.resolve !== <span class="literal">undefined</span> || promiseCapability.reject !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    promiseCapability.resolve = resolve</span><br><span class="line">    promiseCapability.reject = reject</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4. 创建引用</span></span><br><span class="line">  executor.capability = promiseCapability</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> C(executor)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 5. 新建立 promise 的同时应获取到其 resolve 和 reject 方法</span></span><br><span class="line">  <span class="keyword">if</span> (!isCallable(promiseCapability.resolve) || !isCallable(promiseCapability.reject)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  promiseCapability.promise = promise</span><br><span class="line">  <span class="keyword">return</span> promiseCapability</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文主要根据标准逻辑进行了实现，函数结构和命名保持和 ES6 标准完全一致，配合食用更佳，在下文中，将会理清这些函数间的调用关系，欢迎关注。</p>
<p>全文代码在<a href="https://github.com/MondoGao/ES2015-promise-implement" target="_blank" rel="noopener">此仓库</a>可见，欢迎 star fork 提 issue</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-04-28</span><i class="fa fa-tag"></i><a class="tag" href="/categories/fe/" title="fe">fe </a><a class="tag" href="/tags/es6/" title="es6">es6 </a><a class="tag" href="/tags/es2015/" title="es2015">es2015 </a><a class="tag" href="/tags/promise/" title="promise">promise </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://mondogao.github.io/zh/2017/04/28/ecma-2015-promise/,麦冬,ES2015 标准 Promise 深入理解：实现,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/en/2017/11/30/functional-js-basis/" title="Functional Js Basis">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/zh/2017/04/26/a-suggestion-for-git-branch/" title="分支管理最佳实践与团队项目版本管理方案">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>